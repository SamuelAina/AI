
```sql
DBCC SHRINKDATABASE (database_name, target_percent)
```
- `database_name`: The name of the database you want to shrink.
- `target_percent`: The desired free space as a percentage of the database size after the shrink operation. For example, `10` means 10% free space.

Example:
```sql
DBCC SHRINKDATABASE (MyDatabase, 10);
```

### 2. DBCC SHRINKFILE
This command shrinks the size of the specified data or log file for a database.

Syntax:
```sql
DBCC SHRINKFILE (file_name, target_size)
```
- `file_name`: The logical name of the file to shrink. You can get this name from the `sys.database_files` catalog view.
- `target_size`: The desired size of the file in megabytes. If `0` is specified, SQL Server will shrink the file to the smallest size possible.

Example:
```sql
DBCC SHRINKFILE (MyDataFile, 100);
```

### Considerations Before Shrinking
- **Shrinking a database should be done with caution** and typically only in specific scenarios, such as after archiving a significant amount of data. Regularly shrinking databases as part of routine maintenance is not recommended because it can cause fragmentation and degrade performance.
- After shrinking, **it's advisable to reorganize indexes** to mitigate the impact of fragmentation.

### Alternatives to Shrinking
- **Review data retention policies**: Instead of frequently shrinking files, consider if old or unnecessary data can be archived or purged, reducing the need for future shrinks.
- **Monitor file growth settings**: Ensure your database files are set to grow in a controlled manner that minimizes the need to release unused space frequently.

Shrinking operations can be resource-intensive and affect database performance. Therefore, they should ideally be performed during maintenance windows or periods of low activity.

#####################

To determine the free space in a SQL Server database, you can use several methods, including system stored procedures, system views, or SQL Server Management Studio (SSMS) reports. Below are some common approaches to find out the free space in both the data files and log files of your database:

### 1. Using the `sp_spaceused` Stored Procedure
This system stored procedure provides information about the total and unused space in the database.

```sql
EXEC sp_spaceused;
```
Running this command gives you an overview of the database size, unallocated space, and the size of the data and index information.

### 2. Using the `sys.database_files` System View
You can query this system view to get detailed information about the files in the database, including their size and available space.

```sql
SELECT 
    name AS FileName, 
    type_desc AS FileType,
    size/128.0 AS CurrentSizeMB, 
    size/128.0 - CAST(FILEPROPERTY(name, 'SpaceUsed') AS int)/128.0 AS FreeSpaceMB
FROM 
    sys.database_files;
```
This query shows the file name, type (ROWS for data and LOG for log files), current size in megabytes, and free space in megabytes for each file in the database.

### 3. Using the `sys.dm_db_file_space_usage` Dynamic Management View (DMV)
This DMV is useful for finding space usage information for tempdb specifically.

```sql
SELECT 
    name AS FileName, 
    type_desc AS FileType,
    size/128.0 AS CurrentSizeMB, 
    (size/128.0 - CAST(FILEPROPERTY(name, 'SpaceUsed') AS int)/128.0) AS FreeSpaceMB
FROM 
    tempdb.sys.database_files;
```
This query is specifically targeted at tempdb, but you can adapt it for other databases by changing the context using `USE [DatabaseName];` before running a similar query.

### 4. SQL Server Management Studio (SSMS) Reports
If you prefer a graphical interface, SSMS offers a range of reports that include disk usage by tables, databases, etc.

- Connect to your database instance in SSMS.
- Right-click on the database you want to inspect.
- Select **Reports** > **Standard Reports** > **Disk Usage**.

This report provides a visual representation of the disk space used by the database and includes details about the database size, unallocated space, and space used by data and log files.

These methods will help you understand the space utilization in your database, allowing for better database management and planning for future growth or maintenance activities.


########################
In SQL Server, determining whether a string is numeric can be approached in several ways, each with its own advantages and considerations. The method you choose may depend on the specific requirements of your query, such as the range of acceptable numeric formats (integers, decimals, scientific notation, etc.) and the version of SQL Server you are using. Here are some common methods:

### 1. `ISNUMERIC` Function

The `ISNUMERIC` function is the most straightforward way to check if a string is numeric. It returns `1` if the string can be converted to any numeric type and `0` otherwise.

```sql
SELECT CASE WHEN ISNUMERIC(yourColumn) = 1 THEN 'Numeric' ELSE 'Not Numeric' END AS CheckResult
FROM yourTable;
```

**Pros:**
- Simple and easy to use.

**Cons:**
- Can return `1` for strings that might not convert cleanly to a specific numeric type you're interested in (e.g., currency symbols, scientific notation).
- It considers some special characters like `+`, `-`, and `.` as numeric under certain conditions, which might not be desired.

### 2. `TRY_CAST`, `TRY_CONVERT`, and `TRY_PARSE`

Starting with SQL Server 2012, these functions attempt to convert a string to a specified data type, returning `NULL` if the conversion fails. For numeric checks, `TRY_CAST` and `TRY_CONVERT` are more precise than `ISNUMERIC`.

```sql
SELECT CASE WHEN TRY_CAST(yourColumn AS FLOAT) IS NOT NULL THEN 'Numeric' ELSE 'Not Numeric' END AS CheckResult
FROM yourTable;
```

Replace `FLOAT` with the specific numeric type you're interested in, if necessary.

**Pros:**
- More accurate than `ISNUMERIC` for checking if a string can be converted to a specific numeric type.
- `TRY_CONVERT` and `TRY_PARSE` allow for culture-specific formatting considerations (useful for decimals in different locales).

**Cons:**
- Not available in SQL Server versions before 2012.

### 3. `PATINDEX` and `LIKE`

For more specific numeric checks (e.g., integers only), you might resort to pattern matching, though it's more complex and less efficient.

```sql
SELECT CASE WHEN PATINDEX('%[^0-9]%', yourColumn) > 0 THEN 'Not Numeric' ELSE 'Numeric' END AS CheckResult
FROM yourTable;
```

Or using `LIKE` for simpler patterns:

```sql
SELECT CASE WHEN yourColumn NOT LIKE '%[^0-9]%' THEN 'Numeric' ELSE 'Not Numeric' END AS CheckResult
FROM yourTable;
```

**Pros:**
- Offers customizable pattern matching to fit specific numeric formats.
- Works on all SQL Server versions.

**Cons:**
- More complex and potentially less efficient.
- Not suitable for all numeric types without significant complexity.

### Conclusion

The "best" method depends on your specific needs:
- For a general numeric check, `ISNUMERIC` is easiest but least precise.
- For type-specific checks or SQL Server 2012 and later, `TRY_CAST`, `TRY_CONVERT`, and `TRY_PARSE` are preferable.
- For custom pattern checks or older SQL Server versions, `PATINDEX` or `LIKE` can be utilized, acknowledging their complexity and performance considerations.
################

Neeti,
It was great working with you.
You hired me into SCB and you were my first boss there.
You are an incredible personality with exceptional xxx atributes  and fantastiic xxxx atittude.  A valued and trusted coleague and a formidable chess player :)
We must endeavour to keep in touch!!!
Sam
